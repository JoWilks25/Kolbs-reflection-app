Title,Description,EstimateHours,Priority
ReflectionFormatScreen: Choose Reflection Format,"**Goal**
Let the user choose one of three reflection formats (Direct, Reflective, Minimalist) before answering prompts.

## Implementation Overview
- Build ReflectionFormatScreen with 3 large tappable cards representing the formats.
- Store the selected format in Zustand `reflectionDraft.format` (1, 2, or 3).
- Navigate to ReflectionPromptsScreen after selection.

## Implementation Steps

### 1. Screen Layout
- In `screens/ReflectionFormatScreen.tsx`:
  - Display Practice Area name and session intent (optional, read-only header).
  - Render 3 cards:
    - **Direct (1)** – ""Direct, action-oriented"" (3–5 minutes).
    - **Reflective (2)** – ""Deeper, exploratory"" (5–8 minutes).
    - **Minimalist (3)** – ""Ultra-short"" (≈1 minute).

### 2. Card Behavior
- Each card shows:
  - Title (e.g., ""Direct – Action-Oriented"").
  - Description (short 1–2 line summary).
  - Estimated time label (e.g., ""3–5 minutes"").
- On tap:
  ```typescript
  const { setReflectionFormat } = useAppStore();

  const handleSelectFormat = (format: 1 | 2 | 3) => {
    setReflectionFormat(format);
    navigation.navigate('ReflectionPrompts');
  };
  ```

### 3. Zustand Integration
- Ensure store has:
  ```typescript
  reflectionDraft: {
    format: 1 | 2 | 3 | null;
    step2: string;
    step3: string;
    step4: string;
    feedbackRating: number | null;
    feedbackNote: string;
  };

  setReflectionFormat: (format: 1 | 2 | 3) => set((state) => ({
    reflectionDraft: {
      ...state.reflectionDraft,
      format,
    },
  }));
  ```

### 4. Navigation
- Wire in `RootStackNavigator`:
  - `SessionActiveScreen` → `ReflectionFormatScreen` when user taps ""End & Reflect Now"".
  - `ReflectionFormatScreen` → `ReflectionPromptsScreen` on card tap.

## Files Created / Modified
- **Created:**
  - `screens/ReflectionFormatScreen.tsx` – Format picker UI.
- **Modified:**
  - `stores/appStore.ts` – `reflectionDraft` shape, `setReflectionFormat` action.
  - `navigation/RootStackNavigator.tsx` – Add ReflectionFormatScreen route.

## Acceptance Criteria
✓ 3 cards are visible with clear labels and descriptions.
✓ Tapping a card sets `reflectionDraft.format` to 1, 2, or 3.
✓ After tap, app navigates to ReflectionPromptsScreen.
✓ If user returns to this screen, previously selected format appears visually selected (optional but nice to have).
✓ No DB writes occur on this screen.

## Estimate
**2 hours**
",2,High
ReflectionPromptsScreen: Multi-Step Kolb Flow (UI),"**Goal**
Implement the 3-step Kolb reflection flow UI with format-specific prompts and navigation between steps.

## Implementation Overview
- Build ReflectionPromptsScreen as a 3-step wizard for Kolb steps 2–4.
- Use format-specific wording for Direct, Reflective, and Minimalist formats.
- Bind each step to Zustand `reflectionDraft.step2`, `step3`, and `step4`.
- Enforce that each field must be non-empty before completion.

## Implementation Steps

### 1. Screen Structure
- In `screens/ReflectionPromptsScreen.tsx`:
  - Read from Zustand:
    - `currentSession` (for context).
    - `reflectionDraft.format`, `step2`, `step3`, `step4`.
  - If `reflectionDraft.format` is null, redirect back to ReflectionFormatScreen.
  - Local state for current step index (1–3).

### 2. Format-Specific Prompts
- Define prompt text per format and step (from spec):
  - **Direct (1):**
    - Step 2: ""What actually happened?""
    - Step 3: ""What is the main lesson or pattern?""
    - Step 4: ""What will you try or do differently next time?""
  - **Reflective (2):**
    - Step 2: ""What happened, and what stood out?""
    - Step 3: ""What insight, pattern, or assumption did you notice?""
    - Step 4: ""What will you experiment with next time?""
  - **Minimalist (3):**
    - Step 2: ""Key event""
    - Step 3: ""Main takeaway""
    - Step 4: ""Next micro-action"".

### 3. Step UI
- For each step:
  - Show step indicator: ""Step 1 of 3"", ""Step 2 of 3"", ""Step 3 of 3"".
  - Show prompt text based on current format and step.
  - Multiline TextInput bound to `reflectionDraft.step2`, `step3`, or `step4`.
- Buttons:
  - Step 1–2: Back / Next.
  - Step 3: Back / Complete (or Save in edit mode – hooked in later ticket).

### 4. Strict Completion Requirement
- All three steps must be non-empty before allowing completion:
  ```typescript
  const canComplete = (
    reflectionDraft.step2.trim().length > 0 &&
    reflectionDraft.step3.trim().length > 0 &&
    reflectionDraft.step4.trim().length > 0
  );
  ```
- ""Complete"" button on Step 3 is disabled unless `canComplete` is true.

### 5. Zustand Binding
- For each TextInput `onChangeText`, call `updateReflectionDraft(field, value)`:
  ```typescript
  const { reflectionDraft, updateReflectionDraft } = useAppStore();

  const handleChange = (field: 'step2' | 'step3' | 'step4', value: string) => {
    updateReflectionDraft(field, value);
  };
  ```

### 6. Navigation
- On Complete:
  - For now, just navigate to ReflectionFeedbackScreen.
  - Actual DB save of reflection happens in ReflectionFeedbackScreen ticket.

## Files Created / Modified
- **Created:**
  - `screens/ReflectionPromptsScreen.tsx` – Multi-step form.
- **Modified:**
  - `stores/appStore.ts` – Ensure `updateReflectionDraft` exists.
  - `navigation/RootStackNavigator.tsx` – Add ReflectionPromptsScreen route.

## Acceptance Criteria
✓ ReflectionPromptsScreen shows 3 steps with correct format-specific prompts.
✓ TextInputs for step2, step3, and step4 are bound to Zustand `reflectionDraft`.
✓ User can move Back/Next between steps without losing input.
✓ ""Complete"" button is disabled until all three fields have non-empty, trimmed text.
✓ If format is missing, user is redirected back to ReflectionFormatScreen.
✓ On Complete, app navigates to ReflectionFeedbackScreen.

## Estimate
**4 hours**
",4,High
"ReflectionPromptsScreen: Autosave, Edit Mode & Character Limits","**Goal**
Add autosave, edit-mode support, and strict character limits to the ReflectionPromptsScreen, ensuring reliability and editability within the 48-hour window.

## Implementation Overview
- Autosave reflection draft to AsyncStorage as user types (debounced).
- Save on app background to avoid data loss.
- Support editing existing reflections (pre-fill + update instead of insert).
- Enforce 3000-character limit per step with UI feedback.

## Implementation Steps

### 1. Character Limit Enforcement
- Each TextInput enforces a **3000-character max** per field (step2, step3, step4).
- Show a character counter when text length > 2500.
- Block further input or show warning when reaching 3000:
  ```typescript
  const handleTextChange = (field, text) => {
    if (text.length <= 3000) {
      updateReflectionDraft(field, text);
    } else {
      showToast('Maximum 3000 characters reached', 'warning');
    }
  };
  ```

### 2. Autosave on Blur (Debounced)
- On each TextInput `onBlur`:
  - Update Zustand immediately.
  - Trigger a debounced AsyncStorage save of draft answers for this session.
- AsyncStorage implementation:
  ```typescript
  import AsyncStorage from '@react-native-async-storage/async-storage';

  const saveDraftToStorage = async (sessionId: string, draft: ReflectionDraft) => {
    try {
      await AsyncStorage.setItem(
        `reflection_draft_${sessionId}`,
        JSON.stringify(draft)
      );
    } catch (error) {
      console.error('Failed to save draft:', error);
      showToast('Auto-save failed. Please try again.', 'warning');
    }
  };
  ```
- Use a 500ms debounce on save to avoid excessive writes.

### 3. Autosave on App Background
- Subscribe to AppState changes:
  ```typescript
  useEffect(() => {
    const subscription = AppState.addEventListener('change', (state) => {
      if (state === 'background' && currentSession?.id) {
        saveDraftToStorage(currentSession.id, reflectionDraft);
      }
    });
    return () => subscription.remove();
  }, [currentSession?.id, reflectionDraft]);
  ```

### 4. Load Draft on Mount
- On component mount, check for existing draft in AsyncStorage:
  ```typescript
  useEffect(() => {
    const loadDraft = async () => {
      if (!currentSession?.id) return;
      
      const draftJson = await AsyncStorage.getItem(`reflection_draft_${currentSession.id}`);
      if (draftJson) {
        const draft = JSON.parse(draftJson);
        // Restore draft to Zustand
        if (draft.format) setReflectionFormat(draft.format);
        if (draft.step2) updateReflectionDraft('step2', draft.step2);
        if (draft.step3) updateReflectionDraft('step3', draft.step3);
        if (draft.step4) updateReflectionDraft('step4', draft.step4);
      }
    };
    
    loadDraft();
  }, []);
  ```

### 5. Edit Mode Support
- When launched for editing from SeriesTimelineScreen:
  - Screen receives `sessionId` and `edit: true` via navigation params.
  - First check AsyncStorage for unsaved draft (takes priority):
    ```typescript
    const draftJson = await AsyncStorage.getItem(`reflection_draft_${sessionId}`);
    if (draftJson) {
      const draft = JSON.parse(draftJson);
      // Pre-fill from draft
    } else {
      // Otherwise load existing reflection from DB
      const reflection = await db.getAsync(
        'SELECT * FROM reflections WHERE session_id = ?',
        [sessionId]
      );
      // Pre-fill: format, step2answer, step3answer, step4answer
    }
    ```
- In edit mode, ""Complete"" button label becomes **""Save""**.
- Final DB update happens in ReflectionFeedbackScreen ticket (sets `updated_at`).

### 6. Error Handling
- Wrap AsyncStorage calls in try/catch.
- If draft save fails:
  - Log error.
  - Show non-blocking toast: ""Auto-save failed. Please try again."".

## Files Created / Modified
- **Modified:**
  - `screens/ReflectionPromptsScreen.tsx` – Add autosave, edit mode, char limits.
  - `db/queries.ts` – Add helper for fetching existing reflection.
- **Used:**
  - `stores/appStore.ts` – `reflectionDraft`, `updateReflectionDraft`.
  - `@react-native-async-storage/async-storage` – Draft persistence.

## Dependencies
- Ticket: ReflectionPromptsScreen UI (previous ticket).
- Package: `@react-native-async-storage/async-storage` (install if not present).
- DB schema: reflections table (for edit mode).

## Acceptance Criteria
✓ User cannot type more than 3000 characters in any step field.
✓ Character counter appears after 2500 characters.
✓ Draft is saved to AsyncStorage (debounced) when user blurs a field.
✓ Draft is saved to AsyncStorage when app goes to background.
✓ On returning to screen, draft content is restored from AsyncStorage.
✓ In edit mode, existing reflection content pre-fills all three steps (AsyncStorage draft takes priority over DB).
✓ In edit mode, button label changes to ""Save"" instead of ""Complete"".
✓ Errors during autosave show a non-blocking toast and do not crash the app.

## Estimate
**6 hours**
",6,High
ReflectionFeedbackScreen: Rating & Final Save,"**Goal**
Capture quick feedback on the reflection via emoji rating and optional note, then persist the final reflection to the database and clean up draft storage.

## Implementation Overview
- Build ReflectionFeedbackScreen with 5 emoji buttons for feedback rating.
- Add optional text input for feedback note.
- On Finish, insert or update reflection row in DB, clean up AsyncStorage draft, then navigate back to timeline.

## Implementation Steps

### 1. Screen Layout
- In `screens/ReflectionFeedbackScreen.tsx`:
  - Question: ""How did this reflection feel?"".
  - 5 large emoji buttons (single-select):
    - 0 – Confusing / Unclear.
    - 1 – Hard / Frustrating.
    - 2 – Neutral / Meh.
    - 3 – Good / Helpful.
    - 4 – Great / Energizing.
  - Optional expandable text area:
    - Label: ""What made this reflection feel this way? (optional)"".

### 2. Bind to Draft State
- Read/write from Zustand `reflectionDraft.feedbackRating` and `feedbackNote`:
  ```typescript
  const { reflectionDraft, updateReflectionDraft } = useAppStore();

  const handleRatingPress = (rating: 0 | 1 | 2 | 3 | 4) => {
    updateReflectionDraft('feedbackRating', rating);
  };
  ```

### 3. Final Save Logic
- On Finish button press:
  - Build reflection payload from `reflectionDraft` and `lastEndedSessionId`:
    ```typescript
    const reflection = {
      id: generateId(),
      session_id: lastEndedSessionId,
      format: reflectionDraft.format,
      step2_answer: reflectionDraft.step2,
      step3_answer: reflectionDraft.step3,
      step4_answer: reflectionDraft.step4,
      feedback_rating: reflectionDraft.feedbackRating,
      feedback_note: reflectionDraft.feedbackNote,
      completed_at: Date.now(),
      updated_at: null,
    };
    ```
  - Insert into `reflections` table:
    ```sql
    INSERT INTO reflections (
      id, session_id, format,
      step2_answer, step3_answer, step4_answer,
      feedback_rating, feedback_note,
      completed_at, updated_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NULL);
    ```
  - Clean up AsyncStorage draft:
    ```typescript
    await AsyncStorage.removeItem(`reflection_draft_${lastEndedSessionId}`);
    ```
  - Clear `reflectionDraft` in Zustand.
  - Clear `lastEndedSessionId` in Zustand.
  - Navigate to SeriesTimelineScreen for the current Practice Area.

### 4. Edit Mode Handling
- If screen is opened in edit mode (reflection already exists):
  - Instead of INSERT, run UPDATE:
    ```sql
    UPDATE reflections
    SET step2_answer = ?, step3_answer = ?, step4_answer = ?,
        feedback_rating = ?, feedback_note = ?,
        updated_at = ?
    WHERE session_id = ?;
    ```
  - Use existing `reflection.id` (no new ID).
  - Still clean up AsyncStorage draft after save.

### 5. Error Handling
- Wrap DB writes in try/catch.
- On error, show toast: ""Failed to save reflection. Please try again."".
- Do not clear draft from AsyncStorage if save fails (allows retry).

## Files Created / Modified
- **Created:**
  - `screens/ReflectionFeedbackScreen.tsx` – Rating + finish screen.
- **Modified:**
  - `db/queries.ts` – Helpers to insert/update reflections.
- **Used:**
  - `utils/uuid.ts` – `generateId()`.
  - `stores/appStore.ts` – `reflectionDraft`, `clearReflectionDraft`, `lastEndedSessionId`, `clearLastEndedSession`.
  - `@react-native-async-storage/async-storage` – Draft cleanup.
  - Navigation – SeriesTimelineScreen route.

## Dependencies
- ReflectionPromptsScreen (must have collected step2–4).
- DB schema: reflections table.
- Package: `@react-native-async-storage/async-storage`.

## Acceptance Criteria
✓ 5 emoji buttons shown with clear labels (Confusing → Great).
✓ Tapping an emoji sets `reflectionDraft.feedbackRating`.
✓ Optional note input works and updates `feedbackNote`.
✓ On Finish (new reflection), a row is inserted into `reflections` with all fields.
✓ On Finish (edit mode), existing row is updated and `updated_at` is set.
✓ After successful save, AsyncStorage draft is removed.
✓ After save, `reflectionDraft` is cleared in Zustand.
✓ After save, `lastEndedSessionId` is cleared in Zustand.
✓ After save, user is navigated to SeriesTimelineScreen for the Practice Area.
✓ Errors during save show a user-visible message and do not crash the app.
✓ If save fails, AsyncStorage draft is preserved for retry.

## Estimate
**2 hours**
",2,High
Draft Cleanup Utility & Package Setup,"**Goal**
Install AsyncStorage package and implement cleanup logic for orphaned reflection drafts on app launch.

## Implementation Overview
- Install `@react-native-async-storage/async-storage` package.
- Create utility function to clean up old/orphaned drafts.
- Run cleanup on app launch to keep storage lean.

## Implementation Steps

### 1. Install AsyncStorage
- Run:
  ```bash
  npm install @react-native-async-storage/async-storage
  ```
- For iOS, run:
  ```bash
  cd ios && pod install && cd ..
  ```

### 2. Create Cleanup Utility
- In new file `utils/draftCleanup.ts`:
  ```typescript
  import AsyncStorage from '@react-native-async-storage/async-storage';
  import { getDatabase } from '../db/migrations';

  /**
   * Clean up orphaned reflection drafts from AsyncStorage
   * Removes drafts for:
   * - Sessions that don't exist
   * - Sessions older than 48 hours
   * - Sessions that already have reflections
   */
  export async function cleanupOrphanedDrafts(): Promise<void> {
    try {
      const db = getDatabase();
      const allKeys = await AsyncStorage.getAllKeys();
      const draftKeys = allKeys.filter(key => key.startsWith('reflection_draft_'));
      
      if (draftKeys.length === 0) return;

      const now = Date.now();
      const fortyEightHoursMs = 48 * 60 * 60 * 1000;
      let cleanedCount = 0;

      for (const key of draftKeys) {
        const sessionId = key.replace('reflection_draft_', '');
        
        // Check if session exists and its status
        const session = await db.getFirstAsync<{
          id: string;
          ended_at: number | null;
          has_reflection: number;
        }>(
          `SELECT s.id, s.ended_at,
                  CASE WHEN r.id IS NOT NULL THEN 1 ELSE 0 END as has_reflection
           FROM sessions s
           LEFT JOIN reflections r ON r.session_id = s.id
           WHERE s.id = ? AND s.is_deleted = 0`,
          [sessionId]
        );

        // Remove draft if:
        // 1. Session doesn't exist
        // 2. Session already has a reflection
        // 3. Session ended more than 48 hours ago
        if (
          !session ||
          session.has_reflection === 1 ||
          (session.ended_at && (now - session.ended_at) > fortyEightHoursMs)
        ) {
          await AsyncStorage.removeItem(key);
          cleanedCount++;
        }
      }

      if (cleanedCount > 0) {
        console.log(`✅ Cleaned up ${cleanedCount} orphaned reflection draft(s)`);
      }
    } catch (error) {
      console.error('Error cleaning up drafts:', error);
      // Non-blocking - don't throw
    }
  }
  ```

### 3. Call Cleanup on App Launch
- In `App.tsx`, add cleanup call after DB initialization:
  ```typescript
  import { cleanupOrphanedDrafts } from './utils/draftCleanup';

  useEffect(() => {
    const initialize = async () => {
      await runMigrations(); // Existing DB init
      await cleanupOrphanedDrafts(); // New cleanup
      setIsReady(true);
    };
    
    initialize();
  }, []);
  ```

### 4. Optional: Manual Cleanup Trigger
- Add a cleanup button in SettingsScreen (optional, for debugging):
  ```typescript
  <TouchableOpacity onPress={async () => {
    await cleanupOrphanedDrafts();
    Alert.alert('Success', 'Cleaned up old drafts');
  }}>
    <Text>Clean Up Old Drafts</Text>
  </TouchableOpacity>
  ```

## Files Created / Modified
- **Created:**
  - `utils/draftCleanup.ts` – Cleanup utility function.
- **Modified:**
  - `App.tsx` – Call cleanup on app launch.
  - `package.json` – Add AsyncStorage dependency.
- **Optional:**
  - `screens/SettingsScreen.tsx` – Add manual cleanup trigger.

## Dependencies
- Package: `@react-native-async-storage/async-storage` (new).
- DB migrations must be run first.

## Acceptance Criteria
✓ `@react-native-async-storage/async-storage` is installed and working.
✓ Cleanup function correctly identifies orphaned drafts.
✓ Drafts for sessions >48hrs old are removed.
✓ Drafts for sessions with existing reflections are removed.
✓ Drafts for deleted/non-existent sessions are removed.
✓ Cleanup runs automatically on app launch.
✓ Cleanup errors are logged but don't crash the app.
✓ Valid drafts (active, <48hrs, no reflection) are preserved.

## Estimate
**2 hours**
",2,Medium
