Title,Description,EstimateHours,Priority
SessionSetupScreen: Display Previous Intent,"**Goal**
Create the SessionSetupScreen and display the previous session's reflection intent (step 4 answer) to provide context for the new session.

## Implementation Overview
- Build the SessionSetupScreen component that receives `practiceAreaId` from navigation params.
- Display the Practice Area name in the header.
- Query the database for the last session's reflection `step4_answer` (previous intent).
- Show a ""Previous Intent Card"" with collapsible functionality for long text.
- Handle edge cases: no previous sessions, no reflection yet, deleted/moved sessions.

## Implementation Steps

### 1. Create SessionSetupScreen Component
- In `screens/SessionSetupScreen.tsx`:
  - Receive route params: `{ practiceAreaId }`.
  - Fetch Practice Area name from Zustand store or DB.
  - Display Practice Area name in screen header.

### 2. Query Previous Session Intent
- In `db/queries.ts`, add helper:
  ```typescript
  import { getDatabase } from './migrations';

  export const getPreviousSessionIntent = async (practiceAreaId: string) => {
    const db = getDatabase();
    const result = await db.getFirstAsync(
      `SELECT s.*, r.step4_answer as previous_next_action
       FROM sessions s
       LEFT JOIN reflections r ON r.session_id = s.id
       WHERE s.practice_area_id = ?
         AND s.is_deleted = 0
       ORDER BY s.started_at DESC
       LIMIT 1`,
      [practiceAreaId]
    );
    return result;
  };
  ```

### 3. Display Previous Intent Card
- UI Components:
  - **Label:** ""Last time you planned to...""
  - **Text:** 
    - If `previous_next_action` exists: display the text.
    - If no previous session: ""No previous sessions"".
    - If previous session exists but no reflection: ""No previous intent recorded"".
  - **Collapsible:** If text length > 100 characters, show ""Show more"" toggle.

### 4. Handle Edge Cases
- No previous sessions in this Practice Area → show ""No previous sessions"".
- Previous session exists but no reflection yet → show ""No previous intent recorded"".
- Previous session deleted or moved → handled by `s.is_deleted = 0` filter.

### 5. Wire into Component State
```typescript
const [previousIntent, setPreviousIntent] = useState<string>('');
const [isExpanded, setIsExpanded] = useState(false);

useEffect(() => {
  const loadPreviousIntent = async () => {
    const result = await getPreviousSessionIntent(practiceAreaId);
    if (!result) {
      setPreviousIntent('No previous sessions');
    } else if (!result.previous_next_action) {
      setPreviousIntent('No previous intent recorded');
    } else {
      setPreviousIntent(result.previous_next_action);
    }
  };
  loadPreviousIntent();
}, [practiceAreaId]);
```

## Files Created / Modified
- **Created:**
  - `screens/SessionSetupScreen.tsx` - New screen component
- **Modified:**
  - `db/queries.ts` - Add `getPreviousSessionIntent` helper
  - `navigation/RootStackNavigator.tsx` - Add SessionSetupScreen route

## Dependencies
- HomeScreen (navigation from)
- DB schema: `sessions`, `reflections` tables
- Zustand store: `practiceAreas` state (optional for PA name)

## Acceptance Criteria
✓ Screen loads when navigating from HomeScreen with `practiceAreaId`.
✓ Practice Area name displays correctly in header.
✓ Previous Intent Card shows last session's `step4_answer` text.
✓ Shows ""No previous sessions"" for first session in Practice Area.
✓ Shows ""No previous intent recorded"" if last session has no reflection.
✓ Long text (>100 chars) is collapsible with ""Show more"" toggle.
✓ No crashes if Practice Area has 0 sessions.
✓ Edge cases handled gracefully (deleted sessions, missing reflections).

## Estimate
**2 hours**
",2,High
SessionSetupScreen: Intent Input & Target Duration Presets,"**Goal**
Add intent input field and target duration preset buttons to SessionSetupScreen, enabling users to set session goals and optional time targets.

## Implementation Overview
- Add a multiline TextInput for capturing the user's session intent.
- Display 4 target duration preset buttons (15/30/45/60 minutes).
- Allow users to select/deselect presets.
- Enable ""Start Session"" button only when intent is non-empty.
- Support voice input via system keyboard (Wispr Flow).

## Implementation Steps

### 1. Add Intent Input Field
- In `SessionSetupScreen.tsx`:
  ```typescript
  const [intentText, setIntentText] = useState('');

  <TextInput
    multiline
    placeholder=""What is your intent or micro-goal for today?""
    value={intentText}
    onChangeText={setIntentText}
    style={styles.intentInput}
  />
  ```
- No character limit (unlimited text).
- Works with system keyboard including Wispr Flow voice input.

### 2. Add Target Duration Section
- UI Layout:
  - **Label:** ""Practice duration (optional)""
  - **4 preset buttons** side-by-side:
    - ""15 min"" → 900 seconds
    - ""30 min"" → 1800 seconds
    - ""45 min"" → 2700 seconds
    - ""60 min"" → 3600 seconds
  - **Help text:** ""You'll get a notification when time is up, but can continue practicing.""

### 3. Implement Preset Button Logic
```typescript
const [selectedDuration, setSelectedDuration] = useState<number | null>(null);

const durationPresets = [
  { label: '15 min', seconds: 15 * 60 },
  { label: '30 min', seconds: 30 * 60 },
  { label: '45 min', seconds: 45 * 60 },
  { label: '60 min', seconds: 60 * 60 },
];

const handlePresetPress = (seconds: number) => {
  if (selectedDuration === seconds) {
    setSelectedDuration(null); // Deselect if already selected
  } else {
    setSelectedDuration(seconds);
  }
};
```

### 4. Style Selected Button
- Highlighted button: different background color or border.
- Unselected: default button style.
- Example:
  ```typescript
  style={[
    styles.presetButton,
    selectedDuration === preset.seconds && styles.presetButtonSelected
  ]}
  ```

### 5. Add Start Session Button
- **State logic:**
  ```typescript
  const isStartDisabled = intentText.trim().length === 0;
  ```
- Button disabled when intent is empty or whitespace-only.
- Button enabled when user enters content.

### 6. Export Constants (if needed)
- In `utils/constants.ts`, export:
  ```typescript
  export const TARGET_DURATION_PRESETS = [
    { label: '15 min', seconds: 900 },
    { label: '30 min', seconds: 1800 },
    { label: '45 min', seconds: 2700 },
    { label: '60 min', seconds: 3600 },
  ];
  ```

## Files Modified
- **screens/SessionSetupScreen.tsx** - Add intent input + preset buttons
- **utils/constants.ts** - Export `TARGET_DURATION_PRESETS` (if not already)

## Dependencies
- Ticket 1: SessionSetupScreen base component
- utils/constants.ts (for preset values)

## Acceptance Criteria
✓ TextInput accepts unlimited text input (no character limit).
✓ Works with Wispr Flow voice keyboard (system keyboard).
✓ 4 preset buttons display side-by-side: ""15 min"", ""30 min"", ""45 min"", ""60 min"".
✓ Tapping a preset highlights the button and stores duration in seconds.
✓ Tapping the same preset again deselects it (sets `null`).
✓ Help text visible below presets explaining notification behavior.
✓ ""Start Session"" button disabled when intent is empty/whitespace-only.
✓ ""Start Session"" button enabled when intent has content.
✓ UI is responsive and works on different screen sizes.

## Estimate
**3 hours**
",3,High
SessionSetupScreen: Session Creation & Sequential Linking,"**Goal**
Implement session creation logic with sequential linking (previous_session_id chain) and navigation to SessionActiveScreen.

## Implementation Overview
- Wire up ""Start Session"" button handler.
- Query for the last session ID in the current Practice Area (for sequential linking).
- Create a new session record with all required fields.
- Insert session into database with proper `previous_session_id` linking.
- Update Zustand store with session state.
- Navigate to SessionActiveScreen.

## Implementation Steps

### 1. Query Last Session ID
- In `db/queries.ts`, add helper:
  ```typescript
  import { getDatabase } from './migrations';

  export const getLastSessionId = async (practiceAreaId: string) => {
    const db = getDatabase();
    const result = await db.getFirstAsync<{ id: string }>(
      `SELECT id FROM sessions
       WHERE practice_area_id = ?
         AND is_deleted = 0
       ORDER BY started_at DESC
       LIMIT 1`,
      [practiceAreaId]
    );
    return result?.id || null;
  };
  ```

### 2. Create Session Record
- In `db/queries.ts`, add helper:
  ```typescript
  import { getDatabase } from './migrations';

  export const createSession = async (
    sessionData: {
      id: string;
      practice_area_id: string;
      previous_session_id: string | null;
      intent: string;
      target_duration_seconds: number | null;
      started_at: number;
    }
  ) => {
    const db = getDatabase();
    await db.runAsync(
      `INSERT INTO sessions (
        id, practice_area_id, previous_session_id, intent,
        target_duration_seconds, started_at, ended_at, is_deleted
      ) VALUES (?, ?, ?, ?, ?, ?, NULL, 0)`,
      [
        sessionData.id,
        sessionData.practice_area_id,
        sessionData.previous_session_id,
        sessionData.intent,
        sessionData.target_duration_seconds,
        sessionData.started_at,
      ]
    );
  };
  ```

### 3. Implement Start Session Handler
```typescript
import { generateId } from '@/utils/uuid';
import { useAppStore } from '@/stores/appStore';

const handleStartSession = async () => {
  try {
    // 1. Get last session ID for sequential linking
    const lastSessionId = await getLastSessionId(practiceAreaId);

    // 2. Create new session object
    const newSession = {
      id: generateId(),
      practice_area_id: practiceAreaId,
      previous_session_id: lastSessionId, // NULL for first session
      intent: intentText.trim(),
      target_duration_seconds: selectedDuration, // null if not set
      started_at: Date.now(),
    };

    // 3. Insert into database
    await createSession(newSession);

    // 4. Update Zustand store
    const { startSession } = useAppStore.getState();
    startSession(newSession, selectedDuration);

    // 5. Navigate to SessionActiveScreen
    navigation.navigate('SessionActive');
  } catch (error) {
    console.error('Failed to start session:', error);
    // Show error toast
  }
};
```

### 4. Sequential Linking Rules
- **First session** in Practice Area: `previous_session_id = NULL`.
- **Subsequent sessions**: `previous_session_id = lastSessionId`.
- This creates an unbroken chain for Series timeline.

### 5. Zustand Integration
- Ensure `startSession(session, targetDuration)` action exists in store:
  ```typescript
  startSession: (session, targetDuration = null) => set({
    currentSession: session,
    sessionStartTime: Date.now(),
    sessionTimer: 0,
    targetDuration,
    targetReached: false,
  })
  ```

## Files Modified
- **screens/SessionSetupScreen.tsx** - Add `handleStartSession` logic
- **db/queries.ts** - Add `getLastSessionId` and `createSession` helpers

## Dependencies
- Ticket 2: Intent input and duration presets
- utils/uuid: `generateId()`
- Zustand store: `startSession` action
- DB schema: `sessions` table

## Acceptance Criteria
✓ First session in Practice Area has `previous_session_id = NULL`.
✓ Subsequent sessions link to immediately prior session ID.
✓ Session record inserted with all fields correctly:
  - `id`, `practice_area_id`, `previous_session_id`, `intent`, `target_duration_seconds`, `started_at`, `ended_at = NULL`, `is_deleted = 0`.
✓ Zustand store updated with `currentSession`, `sessionStartTime`, `targetDuration`.
✓ Navigation to SessionActiveScreen works correctly.
✓ No crashes if Practice Area has 0 prior sessions (NULL linking works).
✓ Intent is trimmed before saving (no leading/trailing whitespace).

## Estimate
**1 hour**
",1,High
Setup Notification Service for Target Duration Alerts,"**Goal**
Create a notification service to handle iOS notification permissions and trigger alerts when users reach their target practice duration.

## Implementation Overview
- Create `services/notificationService.ts` with notification setup and scheduling functions.
- Request notification permissions on iOS.
- Configure foreground notification handler.
- Implement function to schedule immediate target-reached notification.
- Initialize notification setup in App.tsx on mount.

## Implementation Steps

### 1. Create Notification Service
- In `services/notificationService.ts`:
  ```typescript
  import * as Notifications from 'expo-notifications';

  export const setupNotifications = async (): Promise<boolean> => {
    try {
      // Request permissions (iOS)
      const { status } = await Notifications.requestPermissionsAsync();

      if (status !== 'granted') {
        console.warn('Notification permissions not granted');
        return false;
      }

      // Set handler for foreground notifications
      Notifications.setNotificationHandler({
        handleNotification: async () => ({
          shouldShowAlert: true,
          shouldPlaySound: true,
          shouldSetBadge: false,
        }),
      });

      return true;
    } catch (error) {
      console.error('Failed to setup notifications:', error);
      return false;
    }
  };
  ```

### 2. Implement Target Reached Notification
```typescript
export const scheduleTargetReachedNotification = async (): Promise<void> => {
  try {
    await Notifications.scheduleNotificationAsync({
      content: {
        title: 'Practice time complete!',
        body: 'You reached your target duration. Continue or end session?',
        sound: true,
        data: { type: 'targetreached' },
      },
      trigger: null, // Immediate notification
    });
  } catch (error) {
    console.error('Failed to schedule notification:', error);
  }
};
```

### 3. Initialize in App.tsx
- In `App.tsx`, add on mount:
  ```typescript
  import { setupNotifications } from '@/services/notificationService';

  useEffect(() => {
    setupNotifications();
  }, []);
  ```

### 4. Graceful Degradation
- If permissions denied: log warning, continue app functionality.
- Notification service fails gracefully without crashing the app.
- User can still use timer without notifications.

### 5. Testing Notes
- **iOS Simulator:** Notifications don't work reliably; test on physical device.
- **Physical Device:** Verify notification shows with sound and alert.
- **Foreground:** App in foreground should show in-app alert.
- **Background:** Standard iOS notification behavior.

## Files Created
- **services/notificationService.ts** - Notification setup and scheduling

## Files Modified
- **App.tsx** - Call `setupNotifications()` on mount

## Dependencies
- expo-notifications package (already installed)
- iOS device for testing (simulator has limited support)

## Acceptance Criteria
✓ Notification permissions requested on app launch (iOS).
✓ If permissions denied, app continues without crashing.
✓ Foreground notifications configured to show alert + sound.
✓ `scheduleTargetReachedNotification()` triggers immediate notification.
✓ Notification displays correct title: ""Practice time complete!"".
✓ Notification displays correct body: ""You reached your target duration. Continue or end session?"".
✓ Notification plays sound when triggered.
✓ Service is testable on physical iOS device.
✓ No crashes if notification service fails to initialize.

## Estimate
**2 hours**

## Notes
- This service will be used by SessionActiveScreen (Ticket 6).
- Can be developed in parallel with SessionSetupScreen tickets.
- Test on physical device during development.
",2,High
SessionActiveScreen: Timer Logic & Progress Bar,"**Goal**
Build SessionActiveScreen with a count-up timer that supports two modes: simple stopwatch (no target) and target-based timer with progress bar.

## Implementation Overview
- Create SessionActiveScreen component displaying session info and timer.
- Implement timer that updates every second via Zustand `updateTimer()` action.
- Support two display modes:
  1. **No Target:** Simple stopwatch (MM:SS or HH:MM:SS).
  2. **With Target:** Timer with progress bar showing elapsed/target time.
- Color-code progress bar based on proximity to target.
- Handle timer continuation past target (no auto-stop).

## Implementation Steps

### 1. Create SessionActiveScreen Component
- In `screens/SessionActiveScreen.tsx`:
  - Display Practice Area name (read-only).
  - Display session intent (read-only).
  - Render timer based on mode (target vs no-target).

### 2. Timer Update Logic
```typescript
import { useAppStore } from '@/stores/appStore';
import { formatTime } from '@/utils/timeFormatting';

const SessionActiveScreen = () => {
  const { 
    currentSession, 
    sessionTimer, 
    targetDuration, 
    updateTimer 
  } = useAppStore();

  // Update timer every second
  useEffect(() => {
    const interval = setInterval(() => {
      updateTimer(); // Recalculates from sessionStartTime
    }, 1000);

    return () => clearInterval(interval);
  }, [updateTimer]);

  // Calculate progress (if target exists)
  const progress = targetDuration 
    ? Math.min(sessionTimer / targetDuration, 1.0) // Cap at 100%
    : null;

  const isNearingTarget = targetDuration 
    ? (targetDuration - sessionTimer <= 120 && sessionTimer < targetDuration)
    : false;

  const hasExceededTarget = targetDuration && sessionTimer >= targetDuration;

  // ... render logic
};
```

### 3. Mode 1: No Target Duration
- Display large timer: `formatTime(sessionTimer)`
  - Shows MM:SS format (e.g., ""05:32"").
  - Shows HH:MM:SS format if ≥1 hour (e.g., ""01:05:32"").
- Simple stopwatch counting up indefinitely.

### 4. Mode 2: With Target Duration
- Display timer with target: ""28:45 / 30:00"" (elapsed / target).
- Show progress bar (0-100%):
  - **Green (#4CAF50):** Under target.
  - **Yellow (#FFC107):** Nearing target (last 2 minutes).
  - **Blue (#2196F3):** Exceeded target (bar stays full, timer continues).
- If exceeded, show additional text: ""+02:15 over target"".

### 5. Progress Bar Component
```typescript
const ProgressBar = ({ progress, color }: { progress: number; color: string }) => (
  <View style={styles.progressBarContainer}>
    <View 
      style={[
        styles.progressBarFill, 
        { width: `${progress * 100}%`, backgroundColor: color }
      ]} 
    />
  </View>
);
```

### 6. Timer Display Logic
```typescript
// Mode 1: No target
if (!targetDuration) {
  return <Text style={styles.timer}>{formatTime(sessionTimer)}</Text>;
}

// Mode 2: With target
return (
  <View>
    <Text style={styles.timerWithTarget}>
      {formatTime(sessionTimer)} / {formatTime(targetDuration)}
    </Text>
    <ProgressBar 
      progress={progress} 
      color={hasExceededTarget ? '#2196F3' : isNearingTarget ? '#FFC107' : '#4CAF50'} 
    />
    {hasExceededTarget && (
      <Text style={styles.exceededText}>
        +{formatTime(sessionTimer - targetDuration)} over target
      </Text>
    )}
  </View>
);
```

### 7. Timer Persistence
- Timer survives screen orientation changes (Zustand persists state).
- Timer recalculates from `sessionStartTime` on every update (no drift).

## Files Created
- **screens/SessionActiveScreen.tsx** - New screen component

## Files Modified
- None (uses existing Zustand store)

## Dependencies
- Zustand store: `currentSession`, `sessionTimer`, `targetDuration`, `updateTimer`
- utils/timeFormatting: `formatTime()`
- SessionSetupScreen (navigates from)

## Acceptance Criteria
✓ Timer displays correctly in MM:SS format when < 1 hour.
✓ Timer displays HH:MM:SS format when ≥ 1 hour.
✓ Timer updates every second without lag.
✓ Without target: simple stopwatch display counting up.
✓ With target: shows ""elapsed / target"" format (e.g., ""28:45 / 30:00"").
✓ Progress bar fills 0-100% as timer approaches target.
✓ Progress bar turns **green** under target, **yellow** in last 2 minutes, **blue** after exceeding.
✓ Timer continues past target, showing ""+XX:XX over target"" text.
✓ Practice Area name and intent display correctly (read-only).
✓ Timer survives screen orientation changes (no reset).
✓ No performance issues with 1-second interval updates.

## Estimate
**4 hours**
",4,High
SessionActiveScreen: Target Notifications & Vibration,"**Goal**
Detect when the session timer reaches the target duration and trigger a one-time notification with vibration feedback.

## Implementation Overview
- Monitor timer progress via Zustand state.
- Trigger notification when target duration is reached (only once).
- Trigger vibration pattern when target is reached.
- Use `targetReached` flag in Zustand to prevent duplicate notifications.
- Timer continues running after notification (user decides when to end).

## Implementation Steps

### 1. Import Dependencies
```typescript
import { Vibration } from 'react-native';
import { scheduleTargetReachedNotification } from '@/services/notificationService';
```

### 2. Monitor Target Reached Event
```typescript
const { sessionTimer, targetDuration, targetReached } = useAppStore();

useEffect(() => {
  // Only trigger if:
  // 1. Target is set
  // 2. Timer has reached/exceeded target
  // 3. targetReached flag is still false (prevent duplicates)
  if (targetDuration && sessionTimer >= targetDuration && !targetReached) {
    // Trigger notification
    scheduleTargetReachedNotification();

    // Trigger vibration pattern: [delay, vibrate, pause, vibrate]
    Vibration.vibrate([0, 200, 100, 200]); // Short-long-short pattern

    // Note: targetReached flag is set to true in Zustand updateTimer()
  }
}, [sessionTimer, targetDuration, targetReached]);
```

### 3. Zustand Integration
- Ensure `updateTimer()` in Zustand sets `targetReached = true`:
  ```typescript
  updateTimer: () => set((state) => {
    const newTimer = state.sessionStartTime 
      ? Math.floor((Date.now() - state.sessionStartTime) / 1000)
      : 0;

    const targetJustReached = state.targetDuration && 
      !state.targetReached && 
      newTimer >= state.targetDuration;

    return {
      sessionTimer: newTimer,
      targetReached: state.targetReached || targetJustReached,
    };
  })
  ```

### 4. Notification Behavior
- **Foreground (app open):** In-app alert + sound.
- **Background (app minimized):** Standard iOS notification.
- Notification message: ""Practice time complete! You reached your target duration. Continue or end session?"".

### 5. Vibration Pattern
- Pattern: `[0, 200, 100, 200]`
  - 0ms delay
  - 200ms vibrate
  - 100ms pause
  - 200ms vibrate
- Provides tactile feedback without being disruptive.

### 6. Timer Continues After Notification
- Timer does NOT stop when target is reached.
- User can continue practicing past the target.
- Progress bar stays full (100%), timer shows exceeded time.

## Files Modified
- **screens/SessionActiveScreen.tsx** - Add notification trigger logic

## Dependencies
- Ticket 4: Notification Service (`scheduleTargetReachedNotification`)
- Ticket 5: SessionActiveScreen base (timer logic)
- Zustand store: `targetReached` flag
- react-native: `Vibration` API

## Acceptance Criteria
✓ Notification triggers when timer reaches target duration.
✓ Notification fires only ONCE per session (no duplicates).
✓ Vibration pattern fires when target reached.
✓ Notification displays correct title: ""Practice time complete!"".
✓ Notification displays correct body with guidance.
✓ Timer continues counting past target after notification.
✓ Progress bar remains at 100% after target exceeded.
✓ Works correctly if user sets 15/30/45/60 min targets.
✓ No notification if session has no target duration set.
✓ Testable on physical iOS device (simulator has limited vibration support).

## Estimate
**1.5 hours**

## Testing Notes
- Test on physical device (notifications + vibration don't work well in simulator).
- Verify notification shows with sound and alert.
- Verify vibration pattern is noticeable but not disruptive.
- Test with all 4 preset durations (15/30/45/60 min).
",2,Medium
SessionActiveScreen: End Session Flow & AppState Handling,"**Goal**
Implement two-button end session flow that updates the database and navigates based on user choice, plus handle app backgrounding to preserve timer accuracy.

## Implementation Overview
- Add two buttons: ""End & Reflect Now"" and ""End Session & Reflect Later"".
- Update `session.ended_at` in database when session ends.
- Clear Zustand session state via `endSession()` action.
- Navigate based on user choice (ReflectionFormatScreen or SeriesTimelineScreen).
- Handle app backgrounding: timer continues and recalculates on resume.

## Implementation Steps

### 1. Add End Session Buttons
```typescript
<View style={styles.endButtonsContainer}>
  <TouchableOpacity 
    style={[styles.button, styles.buttonPrimary]}
    onPress={() => handleEndSession('reflectnow')}
  >
    <Text style={styles.buttonText}>End & Reflect Now</Text>
  </TouchableOpacity>

  <TouchableOpacity 
    style={[styles.button, styles.buttonSecondary]}
    onPress={() => handleEndSession('reflectlater')}
  >
    <Text style={styles.buttonText}>End Session & Reflect Later</Text>
  </TouchableOpacity>
</View>
```

### 2. Implement End Session Handler
```typescript
import { useAppStore } from '@/stores/appStore';
import { updateSessionEndTime } from '@/db/queries';

const handleEndSession = async (action: 'reflectnow' | 'reflectlater') => {
  try {
    const { currentSession, currentPracticeArea, endSession } = useAppStore.getState();

    // 1. Update database: set ended_at timestamp
    await updateSessionEndTime(currentSession.id, Date.now());

    // 2. Clear Zustand session state
    endSession();

    // 3. Navigate based on user choice
    if (action === 'reflectnow') {
      // Note: ReflectionFormat route currently doesn't accept params in RootStackNavigator
      // Either update navigation type to accept { sessionId: string } or use Zustand store
      navigation.navigate('ReflectionFormat');
    } else {
      navigation.navigate('SeriesTimeline', { practiceAreaId: currentPracticeArea.id });
    }
  } catch (error) {
    console.error('Failed to end session:', error);
    // Show error toast
  }
};
```

### 3. Add Database Helper
- In `db/queries.ts`:
  ```typescript
  import { getDatabase } from './migrations';

  export const updateSessionEndTime = async (
    sessionId: string, 
    endedAt: number
  ) => {
    const db = getDatabase();
    await db.runAsync(
      'UPDATE sessions SET ended_at = ? WHERE id = ?',
      [endedAt, sessionId]
    );
  };
  ```

### 4. Handle App Backgrounding
```typescript
import { AppState } from 'react-native';

useEffect(() => {
  const subscription = AppState.addEventListener('change', (nextAppState) => {
    if (nextAppState === 'background') {
      // Timer auto-pauses (interval cleared)
      // sessionStartTime preserved in Zustand
    } else if (nextAppState === 'active') {
      // Timer resumes: updateTimer() recalculates from sessionStartTime
      // No drift because it's based on Date.now() - sessionStartTime
    }
  });

  return () => subscription.remove();
}, []);
```

### 5. Zustand endSession Action
- Ensure `endSession()` clears all session state:
  ```typescript
  endSession: () => set({
    currentSession: null,
    sessionStartTime: null,
    sessionTimer: 0,
    targetDuration: null,
    targetReached: false,
  })
  ```

### 6. Navigation Routes
- **Reflect Now:** Navigate to `ReflectionFormatScreen` (sessionId available via Zustand `currentSession` before `endSession()` is called, or update navigation type to accept params).
- **Reflect Later:** Navigate to `SeriesTimelineScreen` with `{ practiceAreaId }`.

## Files Modified
- **screens/SessionActiveScreen.tsx** - Add end session buttons + AppState handling
- **db/queries.ts** - Add `updateSessionEndTime` helper

## Dependencies
- Ticket 5: SessionActiveScreen base (timer)
- Zustand store: `endSession` action
- Navigation: ReflectionFormatScreen, SeriesTimelineScreen routes
- DB schema: `sessions` table

## Acceptance Criteria
✓ Two buttons visible: ""End & Reflect Now"" (primary) and ""Reflect Later"" (secondary).
✓ Tapping ""Reflect Now"" updates DB and navigates to ReflectionFormatScreen.
✓ Tapping ""Reflect Later"" updates DB and navigates to SeriesTimelineScreen.
✓ `session.ended_at` set to current timestamp in database.
✓ Zustand session state clears after ending (all fields reset).
✓ Timer continues correctly if app is backgrounded during session.
✓ Timer auto-corrects on app resume (no drift from background time).
✓ No crashes if app is force-closed during session (`ended_at` stays NULL, session remains active).
✓ Both navigation paths work correctly (pass correct params).

## Estimate
**2.5 hours**

## Notes
- Session with `ended_at = NULL` is considered ""active"" (can be handled in future tickets).
- If app is force-closed, session remains in DB with no end time (acceptable for MVP).
",3,High
SessionActiveScreen: Back Button Confirmation,"**Goal**
Prevent accidental session exits by blocking the back button and showing a confirmation dialog during active sessions.

## Implementation Overview
- Intercept hardware/software back button presses.
- Show confirmation alert: ""End session early?"".
- Allow user to cancel (stay on screen) or end session (trigger Reflect Later flow).
- Works on both iOS (swipe-back) and Android (hardware back).

## Implementation Steps

### 1. Import Dependencies
```typescript
import { useFocusEffect } from '@react-navigation/native';
import { BackHandler, Alert } from 'react-native';
import { useCallback } from 'react';
```

### 2. Implement Back Button Handler
```typescript
useFocusEffect(
  useCallback(() => {
    const onBackPress = () => {
      // Show confirmation alert
      Alert.alert(
        'End session early?',
        'Your session is still active. End now?',
        [
          {
            text: 'Cancel',
            style: 'cancel',
            onPress: () => {}, // Do nothing, stay on screen
          },
          {
            text: 'End Session',
            style: 'destructive',
            onPress: () => handleEndSession('reflectlater'),
          },
        ],
        { cancelable: true }
      );

      return true; // Prevent default back behavior
    };

    // Add event listener for hardware back button (Android)
    BackHandler.addEventListener('hardwareBackPress', onBackPress);

    // Clean up listener
    return () => BackHandler.removeEventListener('hardwareBackPress', onBackPress);
  }, [handleEndSession])
);
```

### 3. iOS Swipe-Back Gesture
- React Navigation automatically blocks swipe-back when `BackHandler` returns `true`.
- The confirmation dialog will also appear on iOS swipe-back gesture.

### 4. Alert Options
- **Cancel:** Closes dialog, keeps user on SessionActiveScreen, session continues.
- **End Session:** Triggers `handleEndSession('reflectlater')`, updates DB, navigates away.

### 5. User Flow
1. User presses back button (hardware or swipe).
2. Alert shows: ""End session early? Your session is still active. End now?"".
3. User chooses:
   - **Cancel:** Alert closes, timer continues.
   - **End Session:** Session ends, navigates to SeriesTimelineScreen.

## Files Modified
- **screens/SessionActiveScreen.tsx** - Add BackHandler logic

## Dependencies
- Ticket 7: SessionActiveScreen end flow (`handleEndSession` function)
- React Navigation: `useFocusEffect`
- React Native: `BackHandler`, `Alert`

## Acceptance Criteria
✓ Pressing back button shows confirmation dialog.
✓ Dialog displays title: ""End session early?"".
✓ Dialog displays message: ""Your session is still active. End now?"".
✓ Tapping ""Cancel"" closes dialog and keeps user on SessionActiveScreen.
✓ Tapping ""End Session"" ends session and navigates away (Reflect Later flow).
✓ Timer continues if user taps ""Cancel"".
✓ Works with hardware back button on Android.
✓ Works with swipe-back gesture on iOS.
✓ No crashes if back button pressed multiple times quickly.

## Estimate
**0.5 hours**

## Notes
- This is a polish/UX enhancement ticket.
- Can be implemented after Ticket 7 (end session flow) is complete.
- Prevents accidental exits during practice sessions.
",1,Low